[[ja:EmacsClient-ja]]
EmacsClient allows one to open a file for editing in an already running Emacs.  Because it doesn't start a new Emacs instance at each invocation, you can setup EmacsClient as the default editor, e.g. in the environment variable EDITOR or VISUAL.  EmacsClient is part of and works only in conjunction with GNU Emacs.  The program GnuClient provides the corresponding functionality for XEmacs, but also works with GnuEmacs.

= Start the Emacs Server =

=== Starting Interactively ===
To enable the Emacs server, add the command 

   (server-start) 

to your init.el.  This is a requirement for using the Emacs client! When the server is running, closing the last Emacs frame will leave the server running. To shut Emacs down completely, call the command `(kill-emacs)'. 

=== Emacs Daemon ===

The command 

 emacs --daemon

will launch an emacs in daemon mode, starting the server, running the init files and then detaching into the background. This is handy for automatically running at launch. This can save you a few seconds since Emacs will already be running by the time you open your first file! This was not supported on Windows before version 25. 

EmacsAsDaemon details various ways to run this command in different distributions, init scripts vs systemd and so on.


= Using EmacsClient =

== The Easy Solution (With Emacs 23+) ==

=== Bash environments ===

Simply replace every place you'd run <tt>emacs</tt> with this command instead. 

{{{
emacsclient -create-frame --alternate-editor=""
}}}

The emacsclient program will connect to a running instance of Emacs if it exists. <tt>-c</tt> tells Emacs to open the file in a new frame, which is optional. 
 Specifying <tt>-a=""</tt> tells emacsclient to start an an instance of emacs if it cannot find one already running.


To use emacsclient as your editor, add the following to your .bashrc:

{{{
export EDITOR="emacsclient -c -a emacs"
}}}



=== Windows ===

See EmacsMsWindowsIntegration for a fairly complete and workable solution for Emacs 23/24, using stock Emacs builds. EmacsMsWindowsIntegration contains info on how to set up taskbar/Start-menu shortcuts and make Emacs open particular file types using emacsclient.  

See MsWindowsGlobalContextMenu to add Emacs client to the right click context menu in Explorer. 

WThirtyTwoFileAssociations to see how to associate file extensions to open with Emacs client on Windows. 



==== Editing with Emacs from Web Browsers ====

===== With Firefox Add-on "It's All Text" + an Elisp file + =====

To execute emacsclient From Firefox to call Windows Native Emacs to edit web pages, see [[Mozilla]] page and comments about add-on /It's all text/.

There is a tool in [[NxhtmlMode][nXhtml]] that allows you to do this.
You can find it in the nXhtml menus under "nXhtml / Tools / External Editor Setup".

===== With a Chrome extension =====
*Edit with Emacs - a Google Chrome browser extension*: Source: http://github.com/stsquad/emacs_chrome or https://chrome.google.com/extensions/detail/ljobjlafonikaiipfkggjbhkghgicgoh to install in Chrome.
This extension by Alex Bennee allows users to edit web-page TEXTAREAs with Emacs.  It's nice to use Emacs when typing in posts or editing Wiki pages.  It uses its own edit-server.el instead of gnuclient or emacsclient currently, and doesn't let you edit page source yet.  //(This is not strictly about emacsclient, but seems related.)//

*MozEx* is a Firefox extension which allows the user to use external programs for editing TEXTAREAs, viewing page source, handling mailto, news, telnet and FTP links.  http://mozex.mozdev.org/

--RobDavenport

==== Editing with Emacs from any text area ====
[http://code.google.com/p/external-exe/ External.exe] allows you to assign a keyboard shortcut to "EMACS editing": Whenever you want to edit text in a text area in Windows, hit the shortcut. Then External.exe copies the text in the text area to a file, opens the file with an external editor, and - once editing has finished - copies back the text from the file into the text area. The source code of External.exe is included in the downloadable zip file, and it is under the GPL.

# Install External.exe.
# Set the editor in the configuration file <tt>external.ini</tt> to: <tt>emacsclient.exe ~f</tt>
# Follow the instructions in the documentation of External.exe.



= Opening Server Files Always in a New Frame =

To open the files designated by emacsclient in their own frame, you can use the following hook as a Server Switch Hook which can be setup in customize-group <RET> Server <RET>, or in your InitFile, as such:

    (add-hook 'server-switch-hook
              (lambda nil
                (let ((server-buf (current-buffer)))
                  (bury-buffer)
                  (switch-to-buffer-other-frame server-buf))))

If you're setting this up via M-x customize, you'll of course want to drop the  (add-hook) call.

You might also want to close the frame when you're done with it. To do this, setup a Server Done Hook in the same section to call delete-frame.

    (add-hook 'server-done-hook 'delete-frame)

I also like emacs to cleanup stuff when I finish the emacsclient, so I add another hook to kill the buffer when finished. This also takes care of weird buffer switching behaviors when closing client buffers.

    (add-hook 'server-done-hook (lambda nil (kill-buffer nil)))

The whole thing is actually in my ##.emacs-custom## file:

  (custom-set-variables
   '(server-done-hook (quote ((lambda nil (kill-buffer nil)) delete-frame)))
   '(server-switch-hook (quote ((lambda nil (let (server-buf) (setq server-buf (current-buffer)) (bury-buffer)      (switch-to-buffer-other-frame server-buf))))))
   )

--TheAnarcat

You can also use `server-kill-new-buffers' instead of calling `kill-buffer' in
your `server-done-hook', e.g.

    (custom-set-variables '(server-kill-new-buffers t))
    (add-hook 'server-done-hook (lambda () (delete-frame)))

--RyanBarrett

= Setting Up emacsclient to Run Emacs Only on X11 =

I've found it very useful to set my $EDITOR to emacsclient, and let it judge wether or not to start emacs, based on the $DISPLAY variable, which is often an indication of running on a faster machine for me. So I've wrote the following script, and installed it as /usr/bin/emacsclient.vim.

<pre>
#! /bin/sh

files="$@"
files=${files:-/dev/zero}

if [ -z "$DISPLAY" ]; then
  exec emacsclient.emacs21 -a vim "$files"
else
  exec emacsclient.emacs21 -a emacs "$files"
fi
</pre>

Note that I avoided calling directly emacsclient, which might be an alternative that points to emacsclient.vim, which would lead to an horrible recursion.

To complete the setup on Debian, I've installed this script as an alternative to the editor command:

<pre>
update-alternatives --install /usr/bin/editor editor /usr/bin/emacsclient.vim 50
</pre>

Now I can choose emacsclient.vim as my editor using:

<pre>
update-alternatives --config editor
</pre>

--TheAnarcat

= Emulating GnuClient in Silently Reloading the changed Buffer in EmacsClient =

Add the following to your InitFile:

    (defadvice server-visit-files (around save-buffers last activate)
      "Try to emulate gnuclient behavior with emacsclient.
    Works only for visiting one buffer at a time."
      (let* ((filen (car (car (ad-get-arg 0))))
             (buf (get-file-buffer filen))
             (this-buf-modified-p nil))
        ;;; the following is copied from server-visit-files, with
        ;;; a modification for the `verify-visited-file-modtime' test
        (if (and buf (set-buffer buf))
            (if (file-exists-p filen)
                ;;; if the file has changed on disk, reload it
                ;;; using `find-file-noselect'
                (if (not (verify-visited-file-modtime buf))
                    (progn
                      (find-file-noselect filen)
                      ;;; if user answered `no', reset modtime anyway
                      ;;; so that server-visit-files doesn't realize the
                      ;;; difference:
                      (set-visited-file-modtime)))
              ;;; if file exists no longer, we let server-visit-files
              ;;; deal with that
              t)
          (setq buf (find-file-noselect filen)))
        (setq this-buf-modified-p (buffer-modified-p buf))
        (set-buffer buf)
        (set-buffer-modified-p nil)
        ad-do-it
        (set-buffer-modified-p this-buf-modified-p)))

From http://docs.kde.org/en/HEAD/kdegraphics/kdvi/inverse-search-editor.html

= Using EmacsClient with screen =

I use screen all the time, and always wanted to get it to autoswitch back and forth between shell and emacs window.
I now figured out how, and here is what I do:

In ~/.screenrc I have:

 screen -t Emacs 1 /usr/bin/emacs

In ~/bin/emacs I have the following:

 #!/bin/sh
 echo $WINDOW >~/tmp/emacsclient-caller
 screen -r -X select 1
 emacsclient "$1"

And in my InitFile I have:

    (add-hook 'after-init-hook 'server-start)
    (add-hook 'server-done-hook
              (lambda ()
                (shell-command
                 "screen -r -X select $(cat ~/tmp/emacsclient-caller)")))

Now I only need to set my EDITOR environment variable
to ~/bin/emacs.

--MarioLang

With MultiTTYSupport emacs branch, simply calling emacsclient -t would be enough and would not require such a hack :) Plus it is really *damn fast* ;)

--XavierMaillard

I've made a screenserver.el that takes this an extra step, allowing you to move to the correct screen window no matter where you run the emacs server.

* http://web.archive.org/web/xor.orodu.net/configs/emacs.d/screenserver.el

--BenJansens

I wanted a do-it-all script, that would:

* run emacsclient, or start emacs in server mode if there wasn't already one.

* return to the right "screen caller window" upon C-x #, even in the case of multiple emacsclients running at the same time.

* just close the buffer without returning to the calling screen window is the buffer is exited using C-x k

* just run a regular emacs if used through sudo.

* be usable as my general EDITOR, which means being smart about whether or not to background itself: if I'm in my shell in a screen session,
    I want it to detach itself automatically,  but not in all other cases since it'd break break mutt, svn, and other apps that explicitely wait on EDITOR
    to return. This "smart auto-backgrounding" feature can be disabled easily if the user wants to.

All you need is to drop and chmod u+x the following shell script somewhere in your PATH:

* http://people.debian.org/~seb/emacs-screen.sh

add this snippet to your .emacs:

  ;; emacsclient/server hook
  (defvar server-seb-mode-map
    (let ((map (make-sparse-keymap)))
      (define-key map "\C-xk"
	'(lambda ()
	   (interactive)
	   (shell-command (concat "touch " "/tmp/blah"))
	   (server-edit)))
      map))
  (define-minor-mode server-seb-mode "Server")
  (add-hook 'server-visit-hook 'server-seb-mode)

and then add the following into one of your shell startup files:
<pre>
  export EDITOR=emacs-screen.sh
</pre>
if you're used to typing 'emacs', maybe also alias it:
<pre>
  alias emacs=emacs-screen.sh
</pre>

--SebastienDelafond

= Using EmacsClient with Dtach =

=== What is dtach ? ===

dtach (Emulate GNU screen's detach feature.)

dtach is a tiny program that emulates the detach feature of GNU screen, 
allowing you to run a program in an environment that is protected from 
the controlling terminal and attach to it later.

Visit the dtach homepage project at http://dtach.sourceforge.net

=== Using it ===

The cool thing with dtach is that you do not have anything to setup,
just run something like:

 dtach -A /tmp/emacs emacs

that's all !

When you want to detach from a running session, just press C-\. To
reattach, run your dtach command again. Very simple and very handy.

= Using emacsclient to make a new frame of a remote Emacs 22 on a local display =

    ssh remote_host -f emacsclient --eval '"(make-frame-on-display \"$DISPLAY\")"'

= Edit in a new frame or in the current frame =

Open a new frame from you shell by adding to your .bashrc or .zshrc

   new-frame() {
      emacsclient -e "(new-frame)"
   }

Edit a file in a new frame by adding to your .bashrc or .zshrc

   edit() {
       local FILE=$1

       if [[ -z $FILE ]]; then
          echo "Missing filename"
          return
       fi

       if [ $FILE[0] != "/" -o $FILE[0] = "~" ]
       then
           FILE="$PWD/$FILE"
       fi

       if [[ -z $2 ]]; then
          emacsclient -n $FILE
       else
          emacsclient -e "(find-file-other-frame \"$FILE\")"
       fi
   }

   edit_new_frame() {
      edit $1 "yes"
   }

[:WMFocus]
= Automatically managing window manager focus =

If you want your window manager to automatically focus the emacs frame
when emacsclient is invoked, then once editing is done, refocus back
to the original window from which emacsclient was invoked, here's how:

First you need wmctrl installed, and a helper script called
<code>current-winid</code>:

<pre>
#!/bin/sh

# Only ttys have $WINDOWID set correctly? Firefox doesn't, anyway.

if ! which wmctrl >/dev/null 2>&1; then
  me=$(basename $0)
  echo "$me: wmctrl not found; aborting." >&2
  exit 1
fi

# Note that the exit in END is what determines the final exit status,
# even t/pre~hough the previous exit initiates the exit.
wmctrl -a :ACTIVE: -v 2>&1 \
  | awk 'BEGIN { exit_status = 1 }
         /^Using window:/ { print $3; exit_status = 0; exit } 
         END { exit exit_status }' \
|| exit 1
</pre>

Then all you need is an emacsclient wrapper script (e.g. call it
<code>switch-to-emacsclient</code>):

<pre>
#!/bin/sh

# Save the current winid so we know what to switch back to from emacs.
client_winid=$(current-winid)

# Switch to emacs and wait for editing to be completed.
wmctrl -xa emacs
emacsclient -a fe "$@"

# Switch back to window from which emacsclient was invoked.
wmctrl -ia $client_winid
</pre>

The really nice thing about this is that it supports multiple emacsclients running at once, and it doesn't matter which order you complete editing of the emacsclient buffers.

Alternative: Lisp:switching_emacsclient.bash
= Saveplace and Emacs server: remembering last point position in files opened with emacsclient(w) =

If you use the package saveplace.el (http://www.emacswiki.org/cgi-bin/wiki/SavePlace) to remember the last position a file was visited at, you may have noticed that opening files with emacsclient(w) the cursor always goes at the beginning of buffer, that is, it looks like emacsclient (or better, emacs server) does not care about save-place being active. I suppose this is a bug. A temporary workaround to this is to set

<pre>
    (setq server-visit-hook (quote (save-place-find-file-hook)))
</pre>

in your .emacs file (or set this option through the customization buffer).

I suppose you must have

<pre>
    (require 'saveplace)
</pre>

in your .emacs file as well in order not to receive error messages.

I also suppose a similar solution works for gnuclient(w), which has apparently similar problems.

-PGLPM

Saveplace with emacsclient doesn't have the described problem in the latest version of GNU emacs. Atleast on 24.2 I don't see this problem.

-- SantoshSivaraj

= Making C-x k end an emacsclient session =

If your fingers are wired to using C-x k to kill off buffers (and you dont like having to type C-x #) then try this :

  (add-hook 'server-switch-hook 
            (lambda ()
              (when (current-local-map)
                (use-local-map (copy-keymap (current-local-map))))
              (local-set-key (kbd "C-x k") 'server-edit)))

[new:WilliamRoe:2010-04-19 13:17 UTC]
If there are no clients, the above code will error. I would suggest the folowing instead:
 
  (add-hook 'server-switch-hook
            (lambda ()
              (when (current-local-map)
                (use-local-map (copy-keymap (current-local-map))))
	      (when server-buffer-clients
		(local-set-key (kbd "C-x k") 'server-edit))))

= Making C-c C-c end a gnuclient session =

This is similar to the C-x k binding above, but uses C-c C-c -- which makes it similar to using gnus -- and is, of course, for the other protocol.

 (add-hook 'gnuserv-visit-hook '(lambda ()
				  (local-set-key [(control c) (control c)]
						 (lambda ()
						   (interactive)
						   (save-buffer)
						   (gnuserv-edit)))))


== Functionality similar to kill-emacs-query-functions for clients ==

`kill-emacs-query-functions' allows one to call functions that query the user about killing emacs, with the potential for aborting the quit.  i have a simple check in my .emacs that works fine for a standalone emacs process but doesn't get called when exiting an emacs client.

 (setq kill-emacs-query-functions
      (cons (lambda () (yes-or-no-p "Really kill Emacs? "))
            kill-emacs-query-functions))

is there some way of achieving similar when killing a client?


== Emacs client return values ==

I wanted to use emacsclient as my editor to svn in Windows, but when I used emacsclientw.exe or emacsclient.exe, the return value when I was done editing was always 1, which made svn to reject my edit. How it is with emacsclient and return values? Is my copy just broken?

A: This is known to be broken currently (16-Oct-09); it always returns 1.  There's some discussion in the help-emacs-windows mailing list about fixing it.


== multiple emacs clients ==

If a first instance of emacs is started (and it starts its server), then a remote login is performed and a second instance started, the new instance will starts its own server and mask or kill the original one. An attempt to use emacsclient at the initial login will then start a client window at the remote login. In case that sounds an unlikely scenario, I achieved it by 1) starting an X11 session with emacs in one window, 2) working on a machine in another room, including an ssh to the first machine and another emacs session, 3) returning to the first machine where I attempted to respond to a Usenet post. The edit appeared in emacs on the second machine.

Is there some way to allow the servers started in different ttys to distinguish themselves from each other ?

== workaround for emacsclient "can't find socket" error on cocoa/ns build (OS X) via ssh ==

I find that after starting emacs server (eg, /Applications/Emacs.app/Contents/MacOS/Emacs --daemon) I can start a client session locally, but emacsclient can't find the socket if I try to create a terminal-only client via ssh (OS X 10.6.2, GNU Emacs 23.1.90.1 compiled with ./configure --with-ns). I've seen this reported as a bug (bug#3992: 23.1.50) on bug-gnu-emacs-gnu. Here's a workaround. 

First, you need to make sure that you're using the right emacsclient binary.  Apple distributes GNU Emacs 22 (installed in /usr/bin), but its emacsclient binary is not compatible with GNU Emacs 23.

<pre>
alias emacsclient="/Applications/Emacs.app/Contents/MacOS/bin/emacsclient"
</pre>

Then, you need to set the server-socket-dir variable in your .emacs so that the standard path assumed by emacsclient is used instead of the path that Emacs 23 defaults to on MacOS X.

<pre>
(setq server-socket-dir (format "/tmp/emacs%d" (user-uid)))
</pre>

Obviously, this needs to be executed before (server-start) is called.

Now you can attach to the server process using the above alias in terminal mode via an ssh session:

 emacsclient -nw

And it also works locally to launch the cocoa GUI:

 emacsclient -c &

I expect that this will fail if you are running multiple servers.

-- Noah Hoffman
edited by:
-- HansHuebner

= Additional notes on OS X / Cocoa Emacs =

I'd had a few problems connecting to the emacs server from <code>emacsclient</code>, until I realised I was using the default <code>/usr/bin/emacsclient</code> when I should've been using the <code>/Applications/Emacs.app/Contents/MacOS/bin/emacsclient</code> ... so make a symlink, 

<pre>
sudo mv /usr/bin/emacsclient /usr/bin/emacsclient.old # backup the original emacsclient.
sudo ln /Applications/Emacs.app/Contents/MacOS/bin/emacsclient /usr/bin/emacsclient # symlink emacsclient from Emacs.app
</pre>

Rather than moving a file installed by the OS, I have symlinked /Applications/Emacs.app/Contents/MacOS/bin/emacsclient to /usr/local/bin/emacsclient. Of course you have to make sure that /usr/local/bin comes before /usr/bin in your $PATH. - [[citizen428]]

Setting emacs to work over tcp will create the <code>~/.emacs.d/server/server</code> socket file, you can then use emacsclient this way...

<pre>
emacsclient  +4:14 FILE

# opens FILE at line 4, col 14. 
</pre>

(I've found there's no need to specify the server, unless you are running more than one Emacs server. )

Set -a and/or -c as you like.

-- Jasonm23

== Piping stdout to an Emacs buffer using emacsclient ==

See [[e-pipe]]

-- LeWang

[new]
I defined the following function within .bashrc and start emacs under cygwin with the command <tt>e</tt>.
<pre>
e() {
    local TMP;
    if [[ "$1" == "-" ]]; then
        TMP="$(mktemp /tmp/emacsstdinXXX)";
        cat >"$TMP";
        if ! emacsclient --alternate-editor /usr/bin/false --eval "(let ((b (create-file-buffer \"*stdin*\"))) (switch-to-buffer b) (insert-file-contents \"${TMP}\") (delete-file \"${TMP}\"))"  > /dev/null 2>&1; then
            emacs --eval "(let ((b (create-file-buffer \"*stdin*\"))) (switch-to-buffer b) (insert-file-contents \"${TMP}\") (delete-file \"${TMP}\"))" &
        fi;
    else
        emacsclient --alternate-editor "emacs" --no-wait "$@" > /dev/null 2>&1 &
    fi;
}
</pre>
Editing a file <tt>text.txt</tt>:
<pre>
e text.txt
</pre>
Piping something:
<pre>
echo "something" | e -
</pre>
Using <tt>--alternate-editor</tt> and <tt>--eval</tt> together did not work for me. I don't know why.
The bad thing about <tt>e</tt> is that it relies on an undocumented feature of emacsclient.
It is assumed that <tt>emacsclient --alternate-editor /usr/bin/false ...</tt> returns the exit code of <tt>false</tt> if the alternate editor is used and that it returns SUCCESS if the server can successfully be contacted.

-- TN

I've simplified this down to the following shell script, which I keep in ~/bin/e:

<pre>
if [ -z "$1" ]
then
    TMP="$(mktemp /tmp/stdin-XXX)"
    cat >$TMP
    emacsclient -a emacs $TMP
    rm $TMP
else
    emacsclient -a emacs "$@"
fi
</pre>

It's not *quite* the same but I value the simplicity of it. With this you no longer need 'e -' to indicate STDIN, e will just look for STDIN whenever no files are specified.

[new]

If you happen to be using Eshell, you can get this via:

<pre>
cat myfile > (switch-to-buffer "*my-buf*")
</pre>

== Setting frame colors differently for graphical clients and console clients ==

See: SettingFrameColorsForEmacsClient

-- GeoffreyTeale

== Color coding (multiple) emacs server instances ==

You can start different emacs server instances w/ different color schemes (so you instantly know which one your using).

This works to set the background color:

<pre>
emacs --daemon=todo --background-color='#93DB80'
emacs --daemon=edit --background-color=yellow
</pre>

But if you try setting the cursor color -- it fails miserably.

Another, more flexible option:

=== starting emacs server (daemon) ===
Example scripts for starting different instances of emacs server:
<pre>
#!/bin/bash

export ESRVNAME=todo
emacs --daemon=$ESRVNAME
</pre>
or
<pre>
#!/bin/bash

export ESRVNAME=edit
emacs --daemon=$ESRVNAME
ps -ef | grep -i 'emacs --daemon'
</pre>

Also see http://www.gnu.org/s/libtool/manual/emacs/Emacs-Server.html#Emacs-Server

=== set color choices in .emacs ===
Set your color choices in your .emacs file:
<pre>
;; set colors for my emacs server instances
(defvar esrvname (getenv "ESRVNAME")) ;; is there a var that provides the server-name?
(ignore-errors ;; this prevents error when environment variable is not set
  (when (string-match "todo" esrvname)
    (setq default-frame-alist
          (append default-frame-alist
                  '((background-color . "#93DB80")
                    (cursor-color . "yellow")
                    )))
    ;; or set a color-theme, e.g., (color-theme-classic)
    )
  (when (string-match "edit" esrvname)
    (setq default-frame-alist
          (append default-frame-alist
                  '((background-color . "yellow")
                    ;; (foreground-color . "black")
                    (cursor-color . "blue")
                    )))
    )
  )
</pre>

=== starting emacsclient ===
An example script for starting emacsclient (for different instances of emacs server):
<pre>
#!/bin/bash

emacsclient -s edit -c "$@"
</pre>

This allows you to pass any parameters to emacsclient, e.g., filenames, or even the '-t' (or '-nw') option (it will override the '-c')

Another example:
<pre>
#!/bin/bash

umask 0007 # you can set a different umask than your default for emcas session
cd ~/docs/todo/
emacsclient -s todo -c ~/docs/todo/work.org &
</pre>

Also see: http://www.gnu.org/s/libtool/manual/emacs/emacsclient-Options.html#emacsclient-Options

= Troubleshooting = 


OweAndersson : Think this works fine, only I get a warning: "Emacsclient ERROR, No connection could be made because the target machine actively refused it"

RobDavenport : Owe - I believe that error means the file ~/.emacs.d/server/server is for an old emacs process.  I delete that file and then it works. (On Windows at least.)



= KDE =
In KDE, you can set File Associations to open in emacsclient instead of KWrite.
----
CategoryExternalUtilities
