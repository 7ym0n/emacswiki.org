== Parsing/Lispification and Lisp interpreter ==

(This section is current as of 2019 -deego)

To set a new term "myterm" to "my notes", you can type one of three things: (1) ,myterm is my notes (2) ,(fs-set-term "myterm" "my notes"), or finally, (3) ,(set-term "myterm" "my notes"). (1) is referrred to as a natural-language- or english- syntax. (2) is the lisp interface form available to the irc user. (3) shows that if the fs- prefixes are omitted, a codewalker adds them right back. Internally, all three expressions eventually convert to form (2) which then converts to (fsi-set-term "myterm" "my notes") before actually getting executed. 

You often use the simple english syntax to command the bot, but as is inevitable with any nlp parsing, you will eventually run into ambiguities and edge-cases. We make no efforts to provide workarounds, and your best option is to use the precise lisp syntax for more fine-tuned control in such cases. But, you shouldn't have to remember the equivalent lisp-form and should simply be able to look it up! You simply ask the bot itself via (fs-parse) which is also aliased to (fs-lispify): 

    <deego> ,(parse "Emacs is a good editor")                                                                                                                                                  
    <fsbot> (fs-set-term "Emacs" "a good editor")

This tells you that sentences of the form "foo is bar" get parsed into an (fs-set-term) form. So far, the bot has merely parsed the command, not actually executed it. 
Next, you actually execute the command and tell the bot that emacs is a good editor:

   <deego> ,Emacs is a good editor                                                                                                                                                          
   <fsbot> Created new note for "Emacs"

An additional note for an existing term is entered via "is also" whose parse is:
 
  <deego> ,(parse "Emacs is also a great OS")                                                                                                                                          
  <fsbot> (fs-set-also "Emacs" "a great OS")


As we mentioned, for convenience, you can skip the fs- prefix when commanding fsbot, and it is always automatically added for you. Thus, instead of having to type (fs-parse), you were able to simply type (parse...).


As you saw above, the bot understands and executes a restricted and modified subset of lisp we refer to as fslisp. These fs- functions and macros use various codewalkers, are carefully designed to avoid the irc user being able to do things like (shell-command "rm -rf /"), (eval '(kill-system)), etc, and are therefore sometimes very different from their usual emacs counterparts. Another source of difference arises because they were written with bot-related functionality in mind. For example, (fs-replace-string) is used to replace strings within the notes of terms, and is thus very  different from the usual (replace-string) found in emacs.

You have about 1000 such fs- commands available, referred to as botcommands. Internally, some botcommands are macros and some are functions. These include some powerful building blocks like (fs-while), (fs-mapc..), (fs-eval), (fs-read), (fs-error), (fs-setq), (fs-apply), (fs-funcall), (fs-quote), (fs-lambda), etc.  

Among those included are  (fs-defun), (fs-fmakunbound), an (fs-defalias). In other words, you can use the initial core fslisp functions to create - or remove - as many more as you like.

Thus, you have read/write access to the fs- space. This rw access applies to all new functions you create, but not to the initial core fs- functionality, which has read-only access. Thus, trying (fmakunbound 'set-term) - equivalently  (fs-fmakunbound 'fs-set-term) - will lead to an error because 'fs-set-term is part of the core functionality. That function helps the bot create new terms, as shown above. It should behave in a consistent fashion, for everyone to use, and should not change just because some irc user changed it via a PM.

Internally, things get pretty complex. For example, (fs-apply SUBJECT OBJECT) is fairly complex because it has to handle all kinds of cases in the secure fs- model: the subject could be a variable, a lambda, a quoted lambda, a quoted symbol, etc. The object could be a symbol, a variable, or a list. Additionally, the subject/object can also be fslisp-expressions that result in any of the choices above. Among other things, in each case, the codewalkers need to ensure that we don't allow jailbreaking out of the fs- namespace.  
  

You can query and search among the ~ 1000 bot-commands available to you using (fs-commands):


    <deego> , (commands "^a")
    <fsbot> 7 matches.  (a ac and append apply apropos av)

This means that you have access to these bot commands that start with a: (fs-a), (fs-ac), (fs-and), etc.

This was, in essence, an apropos-search restricted to functions with the prefix fs-. A related command is fs-apropos, which - you guessed it - does an apropos over emacs functions/variables, but no longer restricted to the fs- prefix:

    <deego> , (apropos "^ac")
    <fsbot> 11 matches.  (acapulco accept-process-output access-file
        accessible-keymaps ache aching acid acons acos
        activate-input-method active-minibuffer-window)


Since you have access to (fs-defun) and (fs-setq), you can define your own fs- functions and set your own fs- variables. Once defined, these remain persistent across sessions. These are referred to as userfunctions and uservariables, respectively. The latter should not be confused with terms, which are set via (fs-set-term), as illustrated above. 


Here's one final reminder that everything you do is actually happening in the fs- space. Example, when you  ,(defun incf (myvar) (+ 1 (apply 'myfun myvar))), it first internally gets parsed as ,(fs-defun fs-incf (fs-myvar) (fs-+ 1 (fs-apply 'fs-myfun fs-myvar))), and it works because fs-defun, fs-apply, and fs-+ are functions/macros that are provided to you in the core functionality, and because you hopefully already defun'd a 'fs-myfun prior to this. Notice how the parser figures out that it needs to prefix the quoted expression as well. It converts 'myfun to 'fs-myfun. (If it didn't, you would be able to jailbreak to access things like 'shell-command). When you type ,(format "%s" 'a), on the other hand, you expect the answer to be "a", and indeed, the parser correctly figures out that it should NOT, in this case, convert 'a to 'fs-a.


fs- stripping: Now, the definition of fs-incf that you just created is built upon many other fs- functions. You can see in the publicly available file userfunctions.el. Or you can ask fsbot to (find-function) the function for you and return a pretty-printed output. When you type ,(find-function 'fs-incf), fsbot will return a readable version of the definition, by stripping all the fs- prefixes. Note again that the actual function-definition has a lot of fs- prefixes all over the place.  Thus, when you see the bot returning this definition: (lambda (myvar) (+ 1 (apply 'myfun myvar)), keep in mind that's just a readable shorthand for (lambda (fs-myvar) (fs-+ 1 (fs-apply 'fs-myfun fs-myvar). The former does not always equal the latter. Fsbot's output is readable but inaccurate if taken literally. If you want the bot to retain the fs- prefixes when printing the definition, you can use (find-function-literally).


fs-find-function: was introduced above; we provide some more details here. (fs-find-function 'foo) first looks for an emacs function 'foo, and when that doesn't work, it looks for a user-function 'fs-foo. Thus, when looking up a userfunction, you can skip the fs-prefix in the quoted expression as well. 'fs-ff is an alias for 'fs-find-function. Thus, you will often see #emacsers typing the english-form ,ff myfun instead of the more verbose form (fs-find-function 'fs-myfun). The english form gets parsed as (fs-find-function 'myfun), which initially looks for 'myfun, falls back upon 'fs-myfun, and eventually returns the fs-stripped definition of 'fs-myfun.


----

ErBot

