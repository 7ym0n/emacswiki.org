== Parsing/Lispification and Lisp interpreter ==

(This section is current as of 2019 -deego)

To set a new term "myterm" to "my notes", you can type one of three things: (1) ,myterm is my notes (2) ,(fs-set-term "myterm" "my notes"), or finally, (3) ,(set-term "myterm" "my notes"). (1) is referrred to as a nlp- or english- syntax. (2) is the lisp interface form available to the irc user. (3) shows that if the fs- prefixes are omitted, a codewalker adds them right back. Internally, all three expressions eventually convert to form (2) which then converts to (fsi-set-term "myterm" "my notes") before actually getting executed. 

You often use the simple nlp-syntax to command the bot, but as is inevitable with any nlp parsing, you will eventually run into ambiguities and edge-cases. We make no efforts to provide workarounds, and your best option is to use the precise lisp syntax for more fine-tuned control in such cases. But, you shouldn't have to remember the equivalent lisp-form and should simply be able to look it up! You simply ask the bot itself via (fs-parse) which is also aliased to (fs-lispify): 

    <deego> ,(parse "Emacs is a good editor")                                                                                                                                                  
    <fsbot> (fs-set-term "Emacs" "a good editor")

This tells you that sentences of the form "foo is bar" get parsed into an (fs-set-term) form. So far, the bot has merely parsed the command, not actually executed it. 
Next, you actually execute the command and tell the bot that emacs is a good editor:

   <deego> ,Emacs is a good editor                                                                                                                                                          
   <fsbot> Created new note for "Emacs"

An additional note for an existing term is entered via "is also" whose parse is:
 
  <deego> ,(parse "Emacs is also a great OS")                                                                                                                                          
  <fsbot> (fs-set-also "Emacs" "a great OS")


As we mentioned, for convenience, you can skip the fs- prefix when commanding fsbot, and it is always automatically added for you. Thus, instead of having to type (fs-parse), you were able to simply type (parse...).


As you saw above, the bot understands and executes a restricted and modified subset of lisp we refer to as fslisp. These fs- functions and macros use various codewalkers, are carefully designed to avoid the irc user being able to do things like (shell-command "rm -rf /"), (eval '(kill-system)), etc, and are therefore sometimes very different from their usual emacs counterparts. Another source of difference arises because they are meant to aid the bot functionality. For example, (fs-replace-string) is used to replace strings within the notes of terms, and is very different from the usual (replace-string) found in emacs.

You have about 1000 such fs- commands available, referred to as botcommands. Internally, some botcommands are macros and some are functions. These include some powerful building blocks like (fs-while), (fs-mapc..), (fs-eval), (fs-read), (fs-error), (fs-setq), (fs-apply), (fs-funcall), (fs-quote), (fs-lambda), etc.  

Among those included are  (fs-defun), (fs-fmakunbound), an (fs-defalias). In other words, you can use the initial core fslisp functions to create - or remove - as many more as you like.

Thus, you have read/write access to the fs- space. This rw access applies to all new functions you create, but not to the initial core fs- functionality, which has read-only access. Thus, trying (fmakunbound 'set-term) - equivalently  (fs-fmakunbound 'fs-set-term) - will lead to an error because 'fs-set-term is part of the core functionality. That function helps the bot create new terms, as shown above. It should behave in a consistent fashion, for everyone to use, and should not change just because some irc user changed it via a PM.

Internally, things get pretty complex. For example, (fs-apply SUBJECT OBJECT) is fairly complex because it has to handle all kinds of cases in the secure fs- model: the subject could be a variable, a lambda, a quoted lambda, a quoted symbol, etc. The object could be a symbol, a variable, or a list. Additionally, the subject/object can also be fslisp-expressions that result in any of the choices above. Among other things, in each case, the codewalkers need to ensure that we don't allow jailbreaking out of the fs- namespace.  
  

You can query and search among the ~ 1000 bot-commands available to you using (fs-commands):


    <deego> , (commands "^a")
    <fsbot> 7 matches.  (a ac and append apply apropos av)

This means that you have access to these bot commands that start with a: (fs-a), (fs-ac), (fs-and), etc.

This was, in essence, an apropos-search restricted to functions with the prefix fs-. A related command is fs-apropos, which - you guessed it - does an apropos over emacs functions/variables, but no longer restricted to the fs- prefix:

    <deego> , (apropos "^ac")
    <fsbot> 11 matches.  (acapulco accept-process-output access-file
        accessible-keymaps ache aching acid acons acos
        activate-input-method active-minibuffer-window)


Since you have access to (fs-defun) and (fs-setq), you can define your own fs- functions and set your own fs- variables. Once defined, these remain persistent across sessions. These are referred to as userfunctions and uservariables, respectively. The latter should not be confused with terms, which are set via (fs-set-term), as illustrated above. 


Here's one final reminder that everything you do is actually happening in the fs- space. Example, when you  ,(defun incf (a) (+ 1 (apply 'myfun a))), it first internally gets parsed as ,(fs-defun fs-incf (fs-a) (fs-+ 1 (fs-apply 'fs-myfun fs-a))), and it works because fs-defun, fs-apply, and fs-+ are functions/macros that are provided to you in the core functionality, and because you hopefully already defun'd a 'fs-myfun prior to this. Notice how the parser figures out that it needs to prefix the quoted expression as well, and convert 'myfun to 'fs-myfun. (If not, you would be able to jailbreak to access things like 'shell-command). When you type ,(format "%s" 'a), on the other hand, you expect the answer to be "a", and indeed, the parser correctly figures out that it should NOT, in this case, convert 'a to 'fs-a.


----

ErBot

