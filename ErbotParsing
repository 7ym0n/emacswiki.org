== Parsing/Lispification and Lisp interpreter ==

(This section is current as of 2019 -deego)

To set the **notes** for new **term** "myterm" to "my notes", you can type one of three things: (1) ##,myterm is my notes## (2) ##,(fs-set-term "myterm" "my notes")##, or finally, (3) ##,(set-term "myterm" "my notes")##. (1) is referrred to as a natural-language- or english- syntax. (2) is the lisp form, and finally, (3) shows that if the `fs-' prefixes are omitted, a codewalker adds them right back. Internally, all three expressions eventually convert to form (2) which then converts to ##(fsi-set-term "myterm" "my notes")## before actually getting executed. 

You often use the easiest paren-free english syntax to command the bot, but as is inevitable with any nlp parsing, you will eventually run into ambiguities, edge-cases and conflicts. Your best option in such cases is to use the precise lisp syntax for more fine-tuned control. But, you shouldn't have to remember the equivalent lisp-form. You should simply be able to look it up! You simply ask the bot itself via ##(fs-parse)## which is also aliased to ##(fs-lispify)##: 

    <deego> ,(parse "Emacs is a good editor")                                                                                                                                                  
    <fsbot> (fs-set-term "Emacs" "a good editor")

This tells you that sentences of the form "foo is bar" get parsed into an `fs-set-term' form. So far, the bot has merely parsed the command, not actually executed it. 
Next, you actually execute the command and tell the bot that Emacs is a good editor:

   <deego> ,Emacs is a good editor                                                                                                                                                          
   <fsbot> Created new note for "Emacs"

This sets the term, persistent across sessions, in the publicly available file **botbbdb**.

An additional note for an existing term is entered via "is also" whose parse is:
 
  <deego> ,(parse "Emacs is also a great OS")                                                                                                                                          
  <fsbot> (fs-set-also "Emacs" "a great OS")


As we mentioned, for convenience, you can skip the `fs-' prefix when commanding fsbot, and it is always automatically added for you. Thus, instead of having to type ##(fs-parse)##, you were able to simply type ##(parse...)##.


As you saw above, the bot understands and executes a restricted and modified subset of lisp we refer to as **fslisp**. These `fs-' functions and macros use various codewalkers, are carefully designed to avoid the irc user being able to do things like ##(shell-command "rm -rf /")##, ##(eval '(kill-system))##, etc, and are therefore sometimes very different from their usual emacs counterparts. Another source of difference arises because they were written with bot-related functionality in mind. For example, `fs-replace-string' is used to replace strings within the notes of terms, and is thus very  different from the usual `replace-string' found in emacs.

You have about 1000 such `fs-' commands available, referred to as **botcommands**. Internally, some botcommands are macros and some are functions. These include some powerful building blocks like `fs-while', `fs-mapcar' and cousins, `fs-eval', `fs-read', `fs-error', `fs-setq', `fs-apply', `fs-funcall', `fs-quote', `fs-lambda', etc.  


Among those included are `fs-defun', `fs-fmakunbound', an `fs-defalias'. In other words, you can build upon the initial botcommands and create - or remove - as many more as you like.

Thus, you have read/write access to the `fs-' space. This rw access applies to all new functions you create, but not to the initial core `fs-' functionality, which has read-only access. Thus, trying ##(fmakunbound 'fmakunbound)## - equivalently  ##(fs-fmakunbound 'fs-fmakunbound)## - will lead to an error because `fs-fmakunbound' is part of the core functionality. Such core functions should behave in a consistent fashion, for everyone to use, and should not change just because some irc user changed them via a PM. Another example of a **core botcommand** is `fs-set-term'.


You can query and search among the ~ 1000 bot-commands available to you using `fs-commands':


    <deego> , (commands "^a")
    <fsbot> 7 matches.  (a ac and append apply apropos av)

This means that you have access to the following bot commands that start with the letter a: `fs-a', `fs-ac', `fs-and', `fs-append', etc.

This was, in essence, an apropos-search, but restricted to items with the prefix `fs-'. A related command is fs-apropos. It searches over all emacs functions/variables, no longer restricting to the `fs-' prefix:

    <deego> , (apropos "^ac")
    <fsbot> 11 matches.  (acapulco accept-process-output access-file
        accessible-keymaps ache aching acid acons acos
        activate-input-method active-minibuffer-window)


Since you have access to `fs-defun' and `fs-setq', you can define your own `fs-' functions and set your own `fs-' variables. Once defined, these remain persistent across sessions. These are referred to as **userfunctions** and **uservariables**, respectively, and get stored in the publicly available files **userfunctions.el** and **uservariables.el**. /Uservariables should not be confused with terms/, which are set via `fs-set-term', as illustrated earlier. 


=== Some notes on the Parser === 

Internally, things get pretty complex. For example, ##(fs-apply SUBJECT OBJECT)## is fairly complex because it has to handle all kinds of cases in the secure `fs-' model: the subject could be a variable, a lambda, a quoted lambda, a quoted symbol, etc. The object could be a variable or a list. Additionally, of course, the subject/object can be other fslisp-expressions that result in any of the aforementioned possibilities. Among other things, in each case, the codewalkers need to ensure that we don't allow jailbreaking out of the `fs-' namespace.  


Here's another reminder that everything you do is actually happening in the `fs-' space. When you  ##,(defun increment (myvar) (+ 1 (apply 'myfun myvar)))##, it first internally gets parsed as ##,(fs-defun fs-increment (fs-myvar) (fs-+ 1 (fs-apply 'fs-myfun fs-myvar)))##. That works because `fs-defun', `fs-apply', and ##`fs-+'## are functions/macros that are provided to you in the core functionality, and because you hopefully already `defun'd a `fs-myfun' prior to this. Notice how the parser figures out that it needs to prefix the quoted expression as well. It converts `myfun' to `fs-myfun'. (If it didn't, you would be able to jailbreak to access things like ##'shell-command##). 

In some contexts, however, quoted expressions should not be prefixed with `fs-'. When you type ##,(format "%s" 'a)##, you expect the answer to be "a", and indeed, the parser correctly figures out that it should NOT, in this case, convert ##'a## to ##'fs-a##.


=== `fs-' stripping ===
The definition of `fs-increment' that you just created is built upon several other `fs-' functions. As we alluded to above, you can immediately see your new function in the publicly available file userfunctions.el. Or you can ask fsbot to `find-function' the function for you and return a pretty-printed output. When you type ##,(find-function 'fs-increment)##, fsbot will return a readable version of the definition, by stripping all the `fs-' prefixes. Note again that the actual function-definition has a lot of `fs-' prefixes all over the place.  Thus, when you see the bot returning this definition: ##(lambda (myvar) (+ 1 (apply 'myfun myvar)))##, keep in mind that's just a readable shorthand for ##(lambda (fs-myvar) (fs-+ 1 (fs-apply 'fs-myfun fs-myvar)))##. The former does not always equal the latter. Fsbot's output is readable but inaccurate if taken literally. If you want the bot to retain the `fs-' prefixes when printing the definition, you can use `find-function-literally'.


=== More on fs-find-function ===
##(fs-find-function 'foo)## first looks for an emacs function `foo', and when that doesn't work, it looks for a userfunction `fs-foo'. Thus, provided a built-in 'foo does not exist, you can use 'foo to refer to 'fs-foo when using fs-find-function. `fs-ff' is an alias for `fs-find-function'. Putting all these shortcuts together: You will often see #emacsers typing the english-form ##,ff myfun## instead of the more verbose form ##(fs-find-function 'fs-myfun)##. The english form gets parsed as ##(fs-find-function 'myfun)##, which initially looks for `myfun', falls back upon `fs-myfun', and eventually returns the `fs-' stripped definition of `fs-myfun'.


----

ErBot

