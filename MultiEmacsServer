=== A fix for an ssh with x tunnel with xserver goes to sleep making emacs server non-responsive ===
This happens when:
1. having emacs daemon running.
2. connect with sshx and run emacsclient -c
3. put the computer who connected with sshx to sleep.
4. awake that computer and connect to sshx and run emacsclient -c.
5. the emacsclient -c will not start a new frame.
The cause is the second time the emacsclient -c is running, the emacs daemon will try to do _XReply to the (unrecognized) dead xserver from before the sleep. The _XReply will get stuck in a select/poll because they have not timeout.
The solution is build from two things - 
1. A "checker" function which starts a timer before the _XReply is called. If the xserver respond then the timer is destroyed and a success is returned. If the xserver does not respond then the timer will trigger a signal. The signal will close the fd of the xserver in the emacs deamon. Usually, when a signal is happened when select/poll is running then they return EINTR. The XCB code sees this EINTR and call the select again, but this time with a closed fd. Executing poll/select with a closed fd returns a different value from them, so the loop will exit, the error handle of libx11 will be called and the terminal will be closed properly.
2. call this checker whenever a new client tries to connect.

Pitfalls:
1. race condition after closing the fd and calling select will not recognize this.
2. This currently replaces my "Multiple XServers (DISPLAYs) + emacsclient " solution.

Put this code in xterm.c before the text "/* Flush display of frame F.  */"

<pre>

#define CLOCKID CLOCK_REALTIME
#define CONN_SIG (SIGRTMAX-1)
#include <signal.h>
#include "X11/Xlibint.h"

static int connection_fd = -1;
void
connection_timeout_handler (int signum)
{
    if (connection_fd != -1) {
        close(connection_fd);
        connection_fd = -1;
    }
}
Status
XCheckConnection (
    register Display *dpy,
    Drawable d, int fd, double timeout)
{

    xGetGeometryReply rep;
    register xResourceReq *req;
    LockDisplay(dpy);
    GetResReq(GetGeometry, d, req);
    Status res = 0;

    sigset_t origmask;
    sigset_t sigmask;
    sigemptyset(&sigmask);
    pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);

    // Create the timer
    timer_t timerid;
    struct sigevent sev;
    struct itimerspec its;
    long long freq_nanosecs;

    struct sigaction new_action, old_action;

    new_action.sa_handler = connection_timeout_handler;
    sigemptyset (&new_action.sa_mask);
    new_action.sa_flags = 0;

    sigaction (CONN_SIG, &new_action, &old_action);

    sev.sigev_notify = SIGEV_SIGNAL;
    sev.sigev_signo = CONN_SIG;
    sev.sigev_value.sival_ptr = &timerid;
    (void) timer_create(CLOCKID, &sev, &timerid);

    freq_nanosecs  = (long long)(timeout * 1000000000);
    its.it_value.tv_sec  = freq_nanosecs / 1000000000;
    its.it_value.tv_nsec = freq_nanosecs % 1000000000;
    its.it_interval.tv_sec = its.it_value.tv_sec;
    its.it_interval.tv_nsec = its.it_value.tv_nsec;

    (void) timer_settime(timerid, 0, &its, NULL);
    connection_fd = fd;

    res = _XReply (dpy, (xReply *)&rep, 0, xTrue);

    (void) timer_delete(timerid);
    pthread_sigmask(SIG_SETMASK, &origmask, NULL);
    sigaction (CONN_SIG, &old_action, NULL);

    UnlockDisplay(dpy);
    SyncHandle();
    return (int)res;
}

int check_frame_connection(struct frame * frame, double timeout)
{
    block_input ();
    int fd = ConnectionNumber (FRAME_X_DISPLAY (frame));
    int res = XCheckConnection (
        FRAME_X_DISPLAY (frame), FRAME_OUTER_WINDOW (frame), fd, timeout);
    unblock_input ();
    return res;
}

DEFUN ("x-check-frame", Fx_check_frame,
       Sx_check_frame, 1, 1, 0,
       doc: /* check the connection with the display of the given frame.  */)
  (Lisp_Object f)
{
    if (!f)
        return Qnil;

    if (NILP (f))
        return Qnil;

    if (Fframep(f) != Qx)
        return Qnil;

    if (!FLOATP (Vx_check_frame_timeout))
        return Qnil;

    /* Default timeout is 0.5 second. This timeout will occur
       only when the libx11 did not noticed the frame was 
       disconnected. */
    double timeout = XFLOAT_DATA (Vx_check_frame_timeout);

    struct frame *frame = XFRAME (f);
    int ret = check_frame_connection (frame, timeout);
    return ret ? Qt : Qnil;
}




</pre>



Put this code in syms_of_xterm:
<pre>

  defsubr (&Sx_check_frame);

  DEFVAR_LISP ("x-check-frame-timeout", Vx_check_frame_timeout,
    doc: /* How long to wait a display to response. */);
  Vx_check_frame_timeout = make_float (0.5);

</pre>

Put this in init.el (replaces the "Multiple XServers (DISPLAYs) + emacsclient" solution)

<pre>
(defun check-frames-connection ()
  (dolist (frame (frame-list))
    (when (eq (framep frame) 'x)
      (x-check-frame frame))))

(setq server-inside-emacs-client nil)
; patches the call at server.el:1237
(defun server-create-window-system-frame-hook(orig-fun &rest args)
  (setq server-inside-emacs-client t)
  (check-frames-connection)
  (apply orig-fun args))
(advice-add 'server-create-window-system-frame :around #'server-create-window-system-frame-hook)

(defun exit-emacs-or-close-frame() (interactive)
       (if server-inside-emacs-client (delete-frame) (save-buffers-kill-emacs)))

</pre>

=== Multiple XServers (DISPLAYs) + emacsclient ===
Each emacs shell have its own environment variables, which is loaded from the frame-parameters which opened that shell.
When working on this shell process from more than one DISPLAYs, it occurs that emacsclient is opened on the DISPLAY from the original frame which created that shell.
To fix this problem we will hook the frame creation function to make sure emacsclient will be opened on the right DISPLAY.

init.el:
<pre>
; patches the call at server.el:1237
(defun server-create-window-system-frame-hook(orig-fun &rest args)
  (let (
        (expected-display (car-safe args))
        (frame-display (frame-parameter (selected-frame) 'display))
        (other-arguments (cdr-safe args))
        )
;  (message "Create server params: %S, frame params: %S" args frame-display)
;  (message "CAR %S is iq %S" expected-display (string-equal (car-safe args) "localhost:current"))
;  (message "CDR %S" other-arguments)
;  (message "REJOIN %S" (cons frame-display other-arguments))
  (if (null frame-display)
      (if (string-equal expected-display "localhost:current")
          (apply orig-fun (cons (getenv "DISPLAY") other-arguments))
        (apply orig-fun args)
        )
    
    (if (string-equal expected-display "localhost:current")
        (apply orig-fun (cons frame-display other-arguments))
      (apply orig-fun args)
      )
    )
  )
  
  )

(advice-add 'server-create-window-system-frame :around #'server-create-window-system-frame-hook)


</pre>

.bashrc:

<pre>
export VISUAL="emacsclient -c --display=localhost:current -a emacs"

</pre>

Known issues - trying to run emacsclient from DISPLAY with no previous emacsclients, where there is a different DISPLAY with existing emacsclients, the emacsclient still opens in the wrong DISPLAY. Fixing it would probably require recompilation of emacsclient to make it send BOTH the needed DISPLAY to show the frame and the localhost:current flag.





== Color coding (multiple) emacs server instances ==

You can start different emacs server instances w/ different color schemes (so you instantly know which one you're using).

This works to set the background color:

<pre>
emacs --daemon=todo --background-color='#93DB80'
emacs --daemon=edit --background-color=yellow
</pre>

But if you try setting the cursor color -- it fails miserably.

[new:PhilHudson:2013-12-08 11:36 UTC]
I use a different color for the fringe on each instance, set using Custom.

----

Another, more flexible option:

=== starting emacs server (daemon) ===
Example scripts for starting different instances of emacs server:
<pre>
#!/bin/bash

export ESRVNAME=todo
emacs --daemon=$ESRVNAME
</pre>
or
<pre>
#!/bin/bash

export ESRVNAME=edit
emacs --daemon=$ESRVNAME
ps -ef | grep -i 'emacs --daemon'
</pre>

Also see http://www.gnu.org/s/libtool/manual/emacs/Emacs-Server.html#Emacs-Server

=== set color choices in .emacs ===
Set your color choices in your .emacs file:
<pre>
;; set colors for my emacs server instances
(defvar esrvname (getenv "ESRVNAME")) ;; is there a var that provides the server-name?
(ignore-errors ;; this prevents error when environment variable is not set
  (when (string-match "todo" esrvname)
    (setq default-frame-alist
          (append default-frame-alist
                  '((background-color . "#93DB80")
                    (cursor-color . "yellow")
                    )))
    ;; or set a color-theme, e.g., (color-theme-classic)
    )
  (when (string-match "edit" esrvname)
    (setq default-frame-alist
          (append default-frame-alist
                  '((background-color . "yellow")
                    ;; (foreground-color . "black")
                    (cursor-color . "blue")
                    )))
    )
  )
</pre>

=== starting emacsclient ===
An example script for starting emacsclient (for different instances of emacs server):
<pre>
#!/bin/bash

emacsclient -s edit -c $@
</pre>

This allows you to pass any parameters to emacsclient, e.g., filenames, or even the '-t' (or '-nw') option (it will override the '-c')

Another example:
<pre>
#!/bin/bash

umask 0007 # you can set a different umask than your default for emcas session
cd ~/docs/todo/
emacsclient -s todo -c ~/docs/todo/work.org &
</pre>

Also see: http://www.gnu.org/s/libtool/manual/emacs/emacsclient-Options.html#emacsclient-Options

----

See also EmacsClient

=== problem and workaround for emacs daemon spinning w/ "back to top level" message ===
Problem:
During the first dozen invocations, "emacs --daemon" started up and cleanly loaded my init files.  But, after making some init file changes (including but possibly not limited to removing my prior font customizations from .emacs-custom.el, in order to go back to the default font), the subsequent invocations hung at the "Starting Emacs daemon" line.  Then, when typing "enter" at the terminal or when connecting via emacsclient, emacs continually spools out the message: "back to top level". Inspection revealed the emacs daemon was chewing up 100% of one of the cpu's.

yum info emacs
Arch        : x86_64
Epoch       : 1
Version     : 23.3
Release     : 8.fc16

Workaround:
Start emacs with "emacs --daemon -q". The first time you connect via emacsclient, open your .emacs file and run 'eval-buffer'.

== Running multiple Emacs daemons under different users ==

[[NicFerrier|I]] run many Emacs instances on a single box, as application servers. Some of them run Elnode, some run ShoesOff, etc... I normally separate these by using different operating system users to run them. Otherwise it is too easy for them to trample on each other.

=== Setting up a complete fresh daemon ===

I always:

* make a new user
* make a specific ##.emacs.d## directory for the new emacs instance
** for example ##.emacs.elpad.d##
** you need this because customs cannot be saved to ##.emacs.d## if you start with -Q
* make a boot script to start (and connect as a client) to it
** I usually copy it from another service, say TeamChat
** the boot script sets the daemon socket specifically
* start the emacs service

=== Problems connecting ===
Sometimes you get problems connecting to these multiple servers. This is normally to do with terminal permissions, especially if you just ##sudo su## from one user to another, you get this:  ##Could not open file## - here's an example:

{{{
elpad@somebox:~$ emacs-local/bin/emacsclient -s /tmp/emacs1007/elpad  elpad-elpa/
Waiting for Emacs...
*ERROR*: Could not open file: /dev/pts/9
}}}

This is down to ownership of the tty. To fix this I just ##ssh## to the user from the local box, that always fixes it:

{{{
ssh elpad@localhost
elpad@somebox:~$ emacs-local/bin/emacsclient -s /tmp/emacs1007/elpad  elpad-elpa/
## starts emacs...
}}}
