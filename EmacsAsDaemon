Emacs supports a client/server mode where new files are opened in a running instance of Emacs. This saves you from having to load configuration and packages for every new file you open. This involves two configuration steps: using EmacsClient to open files, and running the Emacs server. This page focuses on how to launch the server at startup, a.k.a. daemon mode.


= Running emacs like a Daemon  =

This feature was introduced in Emacs 23.1.  Daemon mode starts Emacs loading the user's standard init files, but headless.  The command to run it is: 

<pre>
emacs --daemon
</pre>



= Starting Emacs Daemon with systemd =

[http://www.freedesktop.org/wiki/Software/systemd Systemd] is the supported method of running applications at startup on most Linux distributions. The following configuration file emacs.service will be included in the standard Emacs installation as of 26.1.  All you need to do is copy this to <tt>~/.config/systemd/user/emacs.service</tt>.

    cat ~/.config/systemd/user/emacs.service

{{{
[Unit]
Description=Emacs text editor
Documentation=info:emacs man:emacs(1) https://gnu.org/software/emacs/

[Service]
Type=simple
ExecStart=/c/emax64/bin/emacs.exe --fg-daemon
ExecStop=/c/emax64/bin/emacsclient.exe --eval "(kill-emacs)"
Environment=SSH_AUTH_SOCK=%t/keyring/ssh
Restart=on-failure

[Install]
WantedBy=default.target

}}}



Enable the unit by running:
{{{
systemctl enable --user emacs
systemctl start --user emacs
}}}





== Debian/Ubuntu ==

Depending on your requirements, there are a couple ways to work with <code>emacs --daemon</code>.

=== Basic setup ===

This can be done the easy way (via "Settings > Session and Startup > Application Autostart") or by writing your own <code>.desktop</code> file and placing it in <code>~/.config/autostart</code>. 

=== Comprehensive init scripts ===

Here are two possible init scripts for GNU Debian/Ubuntu to put in /etc/init.d/emacsd.  


[[DebianInitScript]]

[[EmacsdInitScript]]



== Gentoo ==

Gentoo includes support for running Emacs as a daemon in the
<code>app-emacs/emacs-daemon</code> package.

: emerge app-emacs/emacs-daemon

Every user who wants to connect to an Emacs server must have an own
instance of the daemonized Emacs. The init script automatically
determines the user by its name, so you create a symbolic link
(do not copy the script, or you will miss eventual updates!) in your
<code>/etc/init.d</code> directory:

: ln -s emacs /etc/init.d/emacs.''username''

This may be added to the boot sequence (and will run under the user's
privileges)

: rc-update add emacs.''username'' default

Further customizations can be done through the
<code>/etc/conf.d/emacs</code> file, which is extensively commented.
You may also create individual <code>/etc/conf.d/emacs.</code>''username''
files for "multiplexed" user configuration.

== Emacs as Daemon on OS X using Launchd ==

If you're running Emacs 23, you can run Emacs As Daemon via OS X's launchd.  The easiest solution is to use a tool like [http://lingon.sourceforge.net/ Lingon] to create the plist file or can create one manually like this:

    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" 
        "http://www.apple.com/DTDs/PropertyList-1.0.dtd"> 
     <plist version="1.0">
      <dict> 
        <key>Label</key>
        <string>gnu.emacs.daemon</string>
        <key>ProgramArguments</key>
        <array>
          <string>/Applications/Emacs.app/Contents/MacOS/Emacs</string>
          <string>--daemon</string>
        </array>
       <key>RunAtLoad</key>
       <true/>
       <key>ServiceDescription</key>
       <string>Gnu Emacs Daemon</string>
      </dict>
    </plist>


This can then be installed in ##~/Library/LaunchAgents## and loaded via:

   launchctl load -w ~/Library/LaunchAgents/gnu.emacs.daemon.plist

For further instructions see [http://cubiclemuses.com/cm/articles/2009/08/06/emacs-and-os-x-launchd/]

: Link dead? This site http://launchd.info/ seems to suggest we don't need sudo above. Not sure, please delete my remark if you can edit above. 


== Stopping the Emacs Daemon ==

The simplest way to stop the emacs daemon from within emacs is to use the <code>kill-emacs</code> or <code>save-buffers-kill-emacs</code> commands.

From outside of emacs this can be achieved using emacsclient:
{{{
    emacsclient -e '(kill-emacs)'
}}}
This will shutdown the daemon immediately with out prompting or saving files.

If you would like emacs to prompt if there are unsaved buffers or existing clients/frames, you can add the following functions to your .emacs file then use the command:
{{{
    emacsclient -e '(client-save-kill-emacs)'
}}}
The display on which the the new frame should be opened can optionally be specified.

Note: If a prompt is required this function will always open an frame as an x window.

{{{
(defun client-save-kill-emacs(&optional display)
  " This is a function that can bu used to shutdown save buffers and 
shutdown the emacs daemon. It should be called using 
emacsclient -e '(client-save-kill-emacs)'.  This function will
check to see if there are any modified buffers or active clients
or frame.  If so an x window will be opened and the user will
be prompted."

  (let (new-frame modified-buffers active-clients-or-frames)

    ; Check if there are modified buffers or active clients or frames.
    (setq modified-buffers (modified-buffers-exist))
    (setq active-clients-or-frames ( or (> (length server-clients) 1)
					(> (length (frame-list)) 1)
				       ))  

    ; Create a new frame if prompts are needed.
    (when (or modified-buffers active-clients-or-frames)
      (when (not (eq window-system 'x))
	(message "Initializing x windows system.")
	(x-initialize-window-system))
      (when (not display) (setq display (getenv "DISPLAY")))
      (message "Opening frame on display: %s" display)
      (select-frame (make-frame-on-display display '((window-system . x)))))

    ; Save the current frame.  
    (setq new-frame (selected-frame))


    ; When displaying the number of clients and frames: 
    ; subtract 1 from the clients for this client.
    ; subtract 2 from the frames this frame (that we just created) and the default frame.
    (when ( or (not active-clients-or-frames)
	       (yes-or-no-p (format "There are currently %d clients and %d frames. Exit anyway?" (- (length server-clients) 1) (- (length (frame-list)) 2)))) 
      
      ; If the user quits during the save dialog then don't exit emacs.
      ; Still close the terminal though.
      (let((inhibit-quit t))
             ; Save buffers
	(with-local-quit
	  (save-some-buffers)) 
	      
	(if quit-flag
	  (setq quit-flag nil)  
          ; Kill all remaining clients
	  (progn
	    (dolist (client server-clients)
	      (server-delete-client client))
		 ; Exit emacs
	    (kill-emacs))) 
	))

    ; If we made a frame then kill it.
    (when (or modified-buffers active-clients-or-frames) (delete-frame new-frame))
    )
  )


(defun modified-buffers-exist() 
  "This function will check to see if there are any buffers
that have been modified.  It will return true if there are
and nil otherwise. Buffers that have buffer-offer-save set to
nil are ignored."
  (let (modified-found)
    (dolist (buffer (buffer-list))
      (when (and (buffer-live-p buffer)
		 (buffer-modified-p buffer)
		 (not (buffer-base-buffer buffer))
		 (or
		  (buffer-file-name buffer)
		  (progn
		    (set-buffer buffer)
		    (and buffer-offer-save (> (buffer-size) 0))))
		 )
	(setq modified-found t)
	)
      )
    modified-found
    )
  )

}}}

== Using GNOME startup and session manager ==

When the emacs daemon is started as a GNOME startup application (by adding "emacs --daemon" as one of the startup applications), you can use the following code in your init file to make emacs register as a client with the GNOME session manager, and shutdown gracefully when the session ends.

{{{
;;; save & shutdown when we get an "end of session" signal on dbus 
(require 'dbus)

(defun my-register-signals (client-path)
  "Register for the 'QueryEndSession' and 'EndSession' signals from
Gnome SessionManager.

When we receive 'QueryEndSession', we just respond with
'EndSessionResponse(true, \"\")'.  When we receive 'EndSession', we
append this EndSessionResponse to kill-emacs-hook, and then call
kill-emacs.  This way, we can shut down the Emacs daemon cleanly
before we send our 'ok' to the SessionManager."
  (setq my-gnome-client-path client-path)
  (let ( (end-session-response (lambda (&optional arg)
                                 (dbus-call-method-asynchronously
                                  :session "org.gnome.SessionManager" my-gnome-client-path
                                  "org.gnome.SessionManager.ClientPrivate" "EndSessionResponse" nil
                                  t "") ) ) )
         (dbus-register-signal
          :session "org.gnome.SessionManager" my-gnome-client-path
          "org.gnome.SessionManager.ClientPrivate" "QueryEndSession"
          end-session-response )
         (dbus-register-signal
          :session "org.gnome.SessionManager" my-gnome-client-path
          "org.gnome.SessionManager.ClientPrivate" "EndSession"
          `(lambda (arg)
             (add-hook 'kill-emacs-hook ,end-session-response t)
             (kill-emacs) ) ) ) )

;; DESKTOP_AUTOSTART_ID is set by the Gnome desktop manager when emacs
;; is autostarted.  We can use it to register as a client with gnome
;; SessionManager.
(dbus-call-method-asynchronously
 :session "org.gnome.SessionManager"
 "/org/gnome/SessionManager" 
 "org.gnome.SessionManager" "RegisterClient" 'my-register-signals
 "Emacs server" (getenv "DESKTOP_AUTOSTART_ID"))
}}}

== Alternate shutdown method (e.g. via gnome-session-manager) ==

see the discussion at 
http://stackoverflow.com/questions/1167484/how-to-gracefully-shutdown-emacs-daemon/2270603

== Shutdown emacs server ==

This function will ask if you want to save any modified buffers, quit your session, and shutdown the associated emacs server instance.

Add the below code to your .emacs file.  Call it w/ <code>M-x server-shutdown</code>

<pre>
;; define function to shutdown emacs server instance
(defun server-shutdown ()
  "Save buffers, Quit, and Shutdown (kill) server"
  (interactive)
  (save-some-buffers)
  (kill-emacs)
  )
</pre>







=== Multiple XServers (DISPLAYs) + emacsclient ===
Each emacs shell have its own environment variables, which is loaded from the frame-parameters which opened that shell.
When working on this shell process from more than one DISPLAYs, it occurs that emacsclient is opened on the DISPLAY from the original frame which created that shell.
To fix this problem we will hook the frame creation function to make sure emacsclient will be opened on the right DISPLAY.

init.el:
<pre>
; patches the call at server.el:1237
(defun server-create-window-system-frame-hook(orig-fun &rest args)
  (let (
        (expected-display (car-safe args))
        (frame-display (frame-parameter (selected-frame) 'display))
        (other-arguments (cdr-safe args))
        )
;  (message "Create server params: %S, frame params: %S" args frame-display)
;  (message "CAR %S is iq %S" expected-display (string-equal (car-safe args) "localhost:current"))
;  (message "CDR %S" other-arguments)
;  (message "REJOIN %S" (cons frame-display other-arguments))
  (if (null frame-display)
      (if (string-equal expected-display "localhost:current")
          (apply orig-fun (cons (getenv "DISPLAY") other-arguments))
        (apply orig-fun args)
        )
    
    (if (string-equal expected-display "localhost:current")
        (apply orig-fun (cons frame-display other-arguments))
      (apply orig-fun args)
      )
    )
  )
  
  )

(advice-add 'server-create-window-system-frame :around #'server-create-window-system-frame-hook)


</pre>

.bashrc:

<pre>
export VISUAL="emacsclient -c --display=localhost:current -a emacs"

</pre>

Known issues - trying to run emacsclient from DISPLAY with no previous emacsclients, where there is a different DISPLAY with existing emacsclients, the emacsclient still opens in the wrong DISPLAY. Fixing it would probably require recompilation of emacsclient to make it send BOTH the needed DISPLAY to show the frame and the localhost:current flag.





== Color coding (multiple) emacs server instances ==

You can start different emacs server instances w/ different color schemes (so you instantly know which one you're using).

This works to set the background color:

<pre>
emacs --daemon=todo --background-color='#93DB80'
emacs --daemon=edit --background-color=yellow
</pre>

But if you try setting the cursor color -- it fails miserably.

[new:PhilHudson:2013-12-08 11:36 UTC]
I use a different color for the fringe on each instance, set using Custom.

----

Another, more flexible option:

=== starting emacs server (daemon) ===
Example scripts for starting different instances of emacs server:
<pre>
#!/bin/bash

export ESRVNAME=todo
emacs --daemon=$ESRVNAME
</pre>
or
<pre>
#!/bin/bash

export ESRVNAME=edit
emacs --daemon=$ESRVNAME
ps -ef | grep -i 'emacs --daemon'
</pre>

Also see http://www.gnu.org/s/libtool/manual/emacs/Emacs-Server.html#Emacs-Server

=== set color choices in .emacs ===
Set your color choices in your .emacs file:
<pre>
;; set colors for my emacs server instances
(defvar esrvname (getenv "ESRVNAME")) ;; is there a var that provides the server-name?
(ignore-errors ;; this prevents error when environment variable is not set
  (when (string-match "todo" esrvname)
    (setq default-frame-alist
          (append default-frame-alist
                  '((background-color . "#93DB80")
                    (cursor-color . "yellow")
                    )))
    ;; or set a color-theme, e.g., (color-theme-classic)
    )
  (when (string-match "edit" esrvname)
    (setq default-frame-alist
          (append default-frame-alist
                  '((background-color . "yellow")
                    ;; (foreground-color . "black")
                    (cursor-color . "blue")
                    )))
    )
  )
</pre>

=== starting emacsclient ===
An example script for starting emacsclient (for different instances of emacs server):
<pre>
#!/bin/bash

emacsclient -s edit -c $@
</pre>

This allows you to pass any parameters to emacsclient, e.g., filenames, or even the '-t' (or '-nw') option (it will override the '-c')

Another example:
<pre>
#!/bin/bash

umask 0007 # you can set a different umask than your default for emcas session
cd ~/docs/todo/
emacsclient -s todo -c ~/docs/todo/work.org &
</pre>

Also see: http://www.gnu.org/s/libtool/manual/emacs/emacsclient-Options.html#emacsclient-Options

----

See also EmacsClient

=== problem and workaround for emacs daemon spinning w/ "back to top level" message ===
Problem:
During the first dozen invocations, "emacs --daemon" started up and cleanly loaded my init files.  But, after making some init file changes (including but possibly not limited to removing my prior font customizations from .emacs-custom.el, in order to go back to the default font), the subsequent invocations hung at the "Starting Emacs daemon" line.  Then, when typing "enter" at the terminal or when connecting via emacsclient, emacs continually spools out the message: "back to top level". Inspection revealed the emacs daemon was chewing up 100% of one of the cpu's.

yum info emacs
Arch        : x86_64
Epoch       : 1
Version     : 23.3
Release     : 8.fc16

Workaround:
Start emacs with "emacs --daemon -q". The first time you connect via emacsclient, open your .emacs file and run 'eval-buffer'.

== Running multiple Emacs daemons under different users ==

[[NicFerrier|I]] run many Emacs instances on a single box, as application servers. Some of them run Elnode, some run ShoesOff, etc... I normally separate these by using different operating system users to run them. Otherwise it is too easy for them to trample on each other.

=== Setting up a complete fresh daemon ===

I always:

* make a new user
* make a specific ##.emacs.d## directory for the new emacs instance
** for example ##.emacs.elpad.d##
** you need this because customs cannot be saved to ##.emacs.d## if you start with -Q
* make a boot script to start (and connect as a client) to it
** I usually copy it from another service, say TeamChat
** the boot script sets the daemon socket specifically
* start the emacs service

=== Problems connecting ===
Sometimes you get problems connecting to these multiple servers. This is normally to do with terminal permissions, especially if you just ##sudo su## from one user to another, you get this:  ##Could not open file## - here's an example:

{{{
elpad@somebox:~$ emacs-local/bin/emacsclient -s /tmp/emacs1007/elpad  elpad-elpa/
Waiting for Emacs...
*ERROR*: Could not open file: /dev/pts/9
}}}

This is down to ownership of the tty. To fix this I just ##ssh## to the user from the local box, that always fixes it:

{{{
ssh elpad@localhost
elpad@somebox:~$ emacs-local/bin/emacsclient -s /tmp/emacs1007/elpad  elpad-elpa/
## starts emacs...
}}}


== FUBAR: Impossible to connect ==

There is an unfortunate possibility when using the emacs server where the server can be stopped and then all visible frames closed (e.g. server-force-delete + ssh disconnect). As far as I can tell, in this condition it becomes impossible to attach to your running emacs instance. This is a real bummer. As a workaround, you can set up a signal handler to restart the server. You can put the following into your emacs startup elisp:
<pre>
;; define function to restart the server
(defun signal-restart-server ()
  (interactive)
  (message "Caught event %S" last-input-event)
  (server-mode)
  )

;; add the binding to the special-event-map
(define-key special-event-map [sigusr1] 'signal-restart-server)
</pre>

Once that code has been loaded, sending a USR1 to the emacs process will restart the server. You can now reconnect. Joy.

<pre>
doh@bummer ~/ $ emacsclient -nc
emacsclient: can't find socket; have you started the server?
To start the server in Emacs, type "M-x server-start".
emacsclient: No socket or alternate editor.  Please use:

	--socket-name
	--server-file      (or environment variable EMACS_SERVER_FILE)
	--alternate-editor (or environment variable ALTERNATE_EDITOR)

doh@bummer ~/ $ ps auxw | grep emacs
doh     5373  0.0  0.2 483844 28872 ?        Ssl  18:44   0:00 emacs --daemon

doh@bummer ~/ $ kill -USR1 5373
  ## Note: there is no feedback from the command line kill

doh@bummer ~/ $ emacsclient -nc
  ## Note: Joy!

</pre>

NOTE: One other possible way to get the server restarted would be to connect to the process with gdb and then call some function to execute lisp code to restart the server. If anyone knows how to do that I would be very interested in learning how it is done.


== "/tmp/emacs1000 is unsafe" ==

Emacs won't start the daemon if its permissions aren't secure. If you receive an error that /tmp/emacs1000 (or another number) isn't safe, do `ls -l /tmp`. The entry for the emacs1000 directory will probably look like `drwxr-x---`. Simply do a `chmod 700 /tmp/emacs1000` to set them to the correct `drwx------` and start the daemon again.



== Shutdown emacs server ==

This function will ask if you want to save any modified buffers, quit your session, and shutdown the associated emacs server instance.

Add the below code to your .emacs file.  Call it w/ <code>M-x server-shutdown</code>

<pre>
;; define function to shutdown emacs server instance
(defun server-shutdown ()
  "Save buffers, Quit, and Shutdown (kill) server"
  (interactive)
  (save-some-buffers)
  (kill-emacs)
  )
</pre>

