Keycentric -- centralizing key-bindings into one place ([[https://gitlab.com/haicnguyen/keycentric-el.git download]])

== Introduction ==

In my Emacs key-bindings, a single key-event (e.g. "<f5>") is bound in different minor-mode's keymaps, and usually the functions bound to each key perform similar tasks. To change the binding for a single key-event, I need to visit different places in my file to change it.

This library seek to centralize all key-bindings into one place, by combining all key-bindings to the same keyevents in different keymaps into one single place (please see the example above for illustration).

This library does not bind multiple commands to one key, nor does it compose keymaps into a single one as does the built-in function `make-composed-keymap'.


== Features ==

* Easy to search and update key-bindings bound to the same key-event.
* Delaying the keymap binding until the specified feature is loaded.
* An :eval keyword to define a form to handle any extraordinary case.
* Binding multiple keys for multiple (major/minor) modes for multiple keymaps, all in the same form (please see the example below).


== Limitations ==

* Single point of failure. This library seeks to centralize all key-bindings into one place. However, this library will ignore any error during execution so as to avoid choking in any one place.
* Using `eval-after-load' for delayed key-binding for keymap unavailable at the time of execution: any misconfiguration on the key-binding may remain hidden until the feature gets loaded and error is raised.
* Repetition of the keymap names for each key, due to the 1-many mapping of each key to multiple maps.


== Installation ==

After downloading this library to somewhere on your computer (let's call it '''path-to-keycentric''' in the code below):

<pre>
(add-to-list 'load-path path-to-keycentric)
(require 'keycentric)
</pre>


== Usage ==

A simple example:

<pre>
(keycentric `(("<f5>" (nil (global-map . backward-up-list)))))
</pre>


In the example, "nil" in "(nil (global-map . backward-up-list))" means the subsequent keymaps (the global-map in this example) are supposed to be available at the time this form gets executed, so that key-binding can be execute now instead of doing \`eval-after-load' it.


Now for defining the same key event "<f5>" for multiple modes (2 modes in the example below: nil (ie. the always-present "global" mode) and lisp-mode):

<pre>
(keycentric `(("<f5>" (nil (global-map . backward-up-list)))))
                      (lisp-mode (lisp-mode-map . up-list))
</pre>

Assume that `lisp-mode' has not been loaded at the time of execution of this example, then it is equivalent to:

<pre>
(define-key global-map (kbd "<f5>") 'backward-up-list)
(eval-after-load "lisp-mode"
    `(define-key ,lisp-mode-map (kbd "<f5>") up-list))
</pre>

If `lisp-mode' has already been loaded, then it is equivalent to:

<pre>
(define-key global-map (kbd "<f5>") 'backward-up-list)
(define-key lisp-mode-map (kbd "<f5>") 'up-list)
</pre>

To define for multiple key-events ("<f5>" and "<S-f5>" below):

<pre>
(keycentric `((("<f5>" "<S-f5>")    (nil (global-map . backward-up-list))
                                    (lisp-mode (lisp-mode-map . up-list)))))
</pre>

This is equivalent to (assuming `lisp-mode' has not been loaded):

<pre>
(define-key global-map (kbd "<f5>") 'backward-up-list)
(define-key global-map (kbd "<S-f5>") 'backward-up-list)
(eval-after-load "lisp-mode"
    `(define-key ,lisp-mode-map (kbd "<f5>") up-list))
(eval-after-load "lisp-mode"
    `(define-key ,lisp-mode-map (kbd "<S-f5>") up-list))
</pre>


[remap <function>] and lambda form works just like using `define-key':

<pre>
(keycentric `(([remap pop-to-mark-command]
                        (nil (global-map . (lambda ()
                                            (interactive)
                                            (and (revert-buffer nil t)
                                            (message "buffer reverted."))))))))
</pre>

which is equivalent to

<pre>
(define-key global-map [remap pop-to-mark-command]
                        (lambda ()
                          (interactive)
                          (and (revert-buffer nil t)
                          (message "buffer reverted."))))
</pre>


And for multiple keymaps:

<pre>
(keycentric `((("<f5>" "<S-f5>")
               (elisp-mode ((lisp-mode-map emacs-lisp-mode-map lisp-interaction-mode-map) . backward-up-list)))))
</pre>

which is equivalent to:

<pre>
(define-key lisp-mode-map (kbd "<f5>") 'backward-up-list)
(define-key lisp-mode-map (kbd "<S-f5>") 'backward-up-list)
(define-key emacs-lisp-mode-map (kbd "<f5>") 'backward-up-list)
(define-key emacs-lisp-mode-map (kbd "<S-f5>") 'backward-up-list)
(define-key lisp-interaction-mode-map (kbd "<f5>") 'backward-up-list)
(define-key lisp-interaction-mode-map (kbd "<S-f5>") 'backward-up-list)
</pre>


If there are multiple forms starting with the same key-event (eg. multiple forms starting with "<f5>" key-event), then the effect will be the sequential execution of all such forms, from the first to the last.


And to use :eval for flexibility:

<pre>
("<f8>" (eshell (:eval (add-hook 'eshell-mode-hook
                                 (lambda () (define-key eshell-mode-map
                                              keycentric-key
                                              #'view-echo-area-messages))))))
</pre>

This is equivalent to

<pre>
(eval-after-load "eshell"
  `(add-hook ,eshell-mode-hook (lambda ()
                                (define-key ,eshell-mode-map
                                            (kbd "<f8>")
                                            view-echo-area-messages))))
</pre>

In this :eval form, the key-event to be bound could be replaced with the variable `keycentric-key', which is provided as a convenience (user can still re-type the key-event inside the form instead of using the variable `keycentric-key'). Key-Binding for eshell is used in the example because eshell-mode-map is a local-buffer map that is only activated when eshell-mode is activated, thus to define a keymapping for eshell-mode-map one may need to add-hook as in the example.


Last but not least, any arguments in the form can be a list, like this:

<pre>
(keycentric `((("<f5>" "<S-f5>") ((nil lisp-mode) (global-map . backward-up-list) (lisp-mode-map . backward-up-list) (slime-mode-map . backward-up-list)))))
</pre>

but error may be raised if any of the keymap in the form above has not yet been loaded at the time of execution.


== References ==

* [[https://github.com/jwiegley/use-package/blob/master/bind-key.el bind-key.el]] viewed 2019-08-25.


----

CategoryKeys
